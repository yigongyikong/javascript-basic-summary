/**
 * 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
 * 그러나 함수 표현식으로 정의한 함수 표현식 이전에 호출할 수 없다.
 * 함수 선언문과 표현식을 생성 시점이 다르기 때문이다.
 */

// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
    return x + y;
}
/**
 * 모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임(runtime)
 *  이전에 자바스크립트 엔진에 의해 먼저 실행된다.
 * 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는
 *  자바스크립트 코듀의 특징을 함수 호이스팅(function hoisting)이라 한다.
 * 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.
 */

// 함수 표현식
var sub = function (x, y) {
    return x - y;
};
/**
 * 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다.
 * 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.
 * 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만
 *  변수 할당문의 값은 할당문이 실행되는 시점,
 *  즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어
 *  함수 객체가 된다.
 * 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라
 *  변수 호이스팅이 발생한다.
 * 
 * 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다.
 * 이 같은 문제 때문에 함수 선언문 대신 함수 표현식을 사용하는 것을 권장한다.
 */